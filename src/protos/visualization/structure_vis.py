import numpy as npimport pandas as pdimport osimport mathfrom tqdm import trangeimport matplotlib.pyplot as pltimport seaborn as snsfrom scipy.spatial import distance_matrixfrom scipy.cluster.hierarchy import linkage, dendrogramimport plotly.graph_objects as gofrom plotly.subplots import make_subplotsdef structure_vis(    structure,    ligand_structure=None,    grns_to_visualize=None,    highlight_grns=None,    add_edges=False,    opacity=0.3,    name="Unknown Structure",):    protein_structure = structure.copy()    atom_color_map = {        "N": "green",        "C": "black",        "O": "blue",        "S": "orange",        "BR": "violet",        "Cl": "pink",    }    default_color = "lightgrey"  # Default color for non-highlighted atoms    ligand_color = "red"  # Color for ligand atoms    # Ensure the columns are converted to string type for concatenation    protein_structure["hovertext"] = (        "GRN: "        + protein_structure["grn"].astype(str)        + "<br>"        + "Atom Name: "        + protein_structure["res_atom_name"].astype(str)        + "<br>"        + "Residue Name: "        + protein_structure["res_name3l"].astype(str)    )    # Separate NaN GRNs to indicate processing errors    error_structure = protein_structure[pd.isnull(protein_structure["grn"])]    protein_structure = protein_structure[pd.notnull(protein_structure["grn"])]    # Filter the protein structure by GRNs if provided    if grns_to_visualize is not None:        protein_structure_filtered = protein_structure[            protein_structure["grn"].isin(grns_to_visualize)        ]    else:        protein_structure_filtered = protein_structure    # Determine which parts to highlight    if highlight_grns is not None:        highlight_structure = protein_structure_filtered[            protein_structure_filtered["grn"].isin(highlight_grns)        ]        non_highlight_structure = protein_structure_filtered[            ~protein_structure_filtered["grn"].isin(highlight_grns)        ]    else:        # If no highlight_grns provided, treat all as highlighted        highlight_structure = protein_structure_filtered        non_highlight_structure = pd.DataFrame(            columns=protein_structure_filtered.columns        )    # Color assignment function    def assign_color(row):        return atom_color_map.get(row["atom_name"], default_color)    # Assign colors    highlight_structure["color"] = highlight_structure.apply(assign_color, axis=1)    non_highlight_structure["color"] = default_color    data = []    # Function to create scatter trace    def create_scatter_trace(df, name, opacity=1.0):        coords = df[["x", "y", "z"]].astype(np.float16).to_numpy()        return go.Scatter3d(            x=coords[:, 0],            y=coords[:, 1],            z=coords[:, 2],            mode="markers",            marker=dict(size=5, color=df["color"], opacity=opacity),            name=name,            text=df["hovertext"],            hoverinfo="text",        )    # Add highlighted structure trace    if not highlight_structure.empty:        data.append(create_scatter_trace(highlight_structure, "Highlighted Protein"))    # Add non-highlighted structure trace with 70% opacity    if not non_highlight_structure.empty:        data.append(create_scatter_trace(non_highlight_structure, "Protein", opacity=opacity))    # Function to add edges    def add_edges_to_trace(coords, edge_color="lightgrey", max_distance=1.9, opacity=1.0):        dist_matrix = distance_matrix(coords, coords)        edges = np.where((dist_matrix < max_distance) & (dist_matrix > 0))        edge_x, edge_y, edge_z = [], [], []        for i, j in zip(edges[0], edges[1]):            edge_x.extend([coords[i, 0], coords[j, 0], None])            edge_y.extend([coords[i, 1], coords[j, 1], None])            edge_z.extend([coords[i, 2], coords[j, 2], None])        return go.Scatter3d(            x=edge_x,            y=edge_y,            z=edge_z,            mode="lines",            line=dict(color=edge_color, width=5),            opacity=opacity,            hoverinfo="none",            name="Bonds",        )    # Add edges if flag is set    if add_edges:        if not highlight_structure.empty:            highlight_coords = highlight_structure[["x", "y", "z"]].astype(np.float16).to_numpy()            data.append(add_edges_to_trace(highlight_coords))        if not non_highlight_structure.empty:            non_highlight_coords = non_highlight_structure[["x", "y", "z"]].astype(np.float16).to_numpy()            data.append(add_edges_to_trace(non_highlight_coords, opacity=opacity))    # Error residues trace (NaN GRN)    if not error_structure.empty:        error_coords = error_structure[["x", "y", "z"]].astype(np.float16).to_numpy()        error_text = error_structure["hovertext"].to_numpy()        error_trace = go.Scatter3d(            x=error_coords[:, 0],            y=error_coords[:, 1],            z=error_coords[:, 2],            mode="markers",            marker=dict(size=5, color="grey"),            name="Processing Errors",            text=error_text,            hoverinfo="text",        )        data.append(error_trace)    # Add the ligand structure to the plot if provided    if ligand_structure is not None:        ligand_coords = ligand_structure[["x", "y", "z"]].astype(np.float16).to_numpy()        ligand_trace = go.Scatter3d(            x=ligand_coords[:, 0],            y=ligand_coords[:, 1],            z=ligand_coords[:, 2],            mode="markers",            marker=dict(size=5, color=ligand_color),            name="Ligand",        )        data.append(ligand_trace)        if add_edges:            data.append(add_edges_to_trace(ligand_coords, edge_color=ligand_color))            protein_coords = protein_structure_filtered[["x", "y", "z"]].astype(np.float16).to_numpy()            ligand_protein_dist = distance_matrix(ligand_coords, protein_coords)            interactions = np.where(ligand_protein_dist < 2.0)            interaction_x, interaction_y, interaction_z = [], [], []            for i, j in zip(interactions[0], interactions[1]):                interaction_x.extend([ligand_coords[i, 0], protein_coords[j, 0], None])                interaction_y.extend([ligand_coords[i, 1], protein_coords[j, 1], None])                interaction_z.extend([ligand_coords[i, 2], protein_coords[j, 2], None])            interaction_trace = go.Scatter3d(                x=interaction_x,                y=interaction_y,                z=interaction_z,                mode="lines",                line=dict(color="purple", width=5, dash="dash"),                hoverinfo="none",                name="Ligand-Protein Interactions",            )            data.append(interaction_trace)    fig = go.Figure(data=data)    fig.update_layout(        scene=dict(            xaxis=dict(visible=False, showgrid=False, showline=False, zeroline=False),            yaxis=dict(visible=False, showgrid=False, showline=False, zeroline=False),            zaxis=dict(visible=False, showgrid=False, showline=False, zeroline=False),            bgcolor="rgba(0,0,0,0)",            aspectmode="manual",            aspectratio=dict(x=1, y=1, z=1),        ),        title=f"Visualization of {name}",        autosize=False,        width=800,        height=800,        paper_bgcolor="white",        plot_bgcolor="white",        margin=dict(l=0, r=0, t=40, b=0),    )    return figdef plot_angles_for_gen_pos(dfl, region=[1, 130], legend=True):    categories = [np.unique(df["pdb_id"])[0] for df in dfl]    cmap = plt.cm.get_cmap("RdYlGn", len(categories))    colors = np.linspace(0, len(categories) - 1, len(categories))    colordict = dict(zip(categories, colors))    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(24, 12))    xlabel = "generic position numbers"    ylabel = "degrees"    xtick_min, xtick_max = region    nsteps = int(round(xtick_max - xtick_min, 2) / 0.01)    xticks = np.linspace(xtick_min, xtick_max, nsteps + 1)    for i, cat in enumerate(categories):        c = int(colordict[cat])        df = dfl[i]        df["auth_seq_id"] = df["auth_seq_id"].astype(int)        roi = df[            (df["auth_seq_id"] >= region[0])            & (df["auth_seq_id"] < region[1])            & (df["res_atom_name"] == "CA")        ].copy()        roi["phi"] = roi.apply(lambda x: float(x.phi), axis=1)        roi["omega"] = roi.apply(lambda x: float(x.omega), axis=1)        roi["psi"] = roi.apply(lambda x: float(x.psi), axis=1)        tot_len = len(roi["phi"].to_list()) + len(roi["omega"].to_list()) + len(roi["psi"].to_list())        if tot_len > 0:            roi.plot(                kind="line",                x="auth_seq_id",                y="phi",                ax=axes[0],                subplots=True,                color=cmap(c),                xticks=xticks,                label=cat,            )            if legend:                axes[0].legend(bbox_to_anchor=(1.0, 1.0))            axes[0].set_xlabel(xlabel)            axes[0].set_ylabel(ylabel)            axes[0].set_title("Psi Angles")            roi.plot(                kind="line",                x="auth_seq_id",                y="psi",                ax=axes[1],                subplots=True,                color=cmap(c),                xticks=xticks,                label=cat,            )            if legend:                axes[1].legend(bbox_to_anchor=(1.0, 1.0))            axes[1].set_xlabel(xlabel)            axes[1].set_ylabel(ylabel)            axes[1].set_title("Phi Angles")    plt.show()def rotate_and_save_plot(fig, k, folder="plots/rotation_frames/", figure_name="test/", camera_distance=2, save=False):    folder_name = folder + figure_name    if not os.path.exists(folder_name):        os.makedirs(folder_name)    fig.update_scenes(xaxis_visible=False, yaxis_visible=False, zaxis_visible=False)    for i in trange(k):        angle = 360.0 * (i / k)        camera = dict(            eye=dict(                x=camera_distance * math.cos(math.radians(angle)),                y=camera_distance * math.sin(math.radians(angle)),                z=0.5 * camera_distance,            )        )        fig.update_layout(scene_camera=camera, showlegend=False)        if save:            fig.write_image(os.path.join(folder_name, f"frame_{i:03d}.png"))        else:            fig.show()def plot_structure(coords):    fig = go.Figure()    fig.add_trace(        go.Scatter3d(            x=np.array(coords)[:, 0],            y=np.array(coords)[:, 1],            z=np.array(coords)[:, 2],            mode="markers",            marker=dict(size=2, color="orange"),            name="Protein",        )    )    fig.update_layout(        scene=dict(            xaxis_title="X",            yaxis_title="Y",            zaxis_title="Z",        )    )    return figdef plot_structures(coords1, coords2):    fig = go.Figure()    fig.add_trace(        go.Scatter3d(            x=np.array(coords1)[:, 0],            y=np.array(coords1)[:, 1],            z=np.array(coords1)[:, 2],            mode="markers",            marker=dict(size=2, color="orange"),            name="Protein1",        )    )    fig.add_trace(        go.Scatter3d(            x=np.array(coords2)[:, 0],            y=np.array(coords2)[:, 1],            z=np.array(coords2)[:, 2],            mode="markers",            marker=dict(size=2, color="blue"),            name="Protein2",        )    )    fig.update_layout(        scene=dict(            xaxis_title="X",            yaxis_title="Y",            zaxis_title="Z",            aspectmode="data",        )    )    return figdef plot_structure_alignment(coords1, coords2, coords2_rot):    fig = make_subplots(        rows=1,        cols=2,        subplot_titles=("Before Alignment", "After Alignment"),        specs=[[{"type": "scatter3d"}, {"type": "scatter3d"}]],    )    fig.add_trace(        go.Scatter3d(            x=np.array(coords1)[:, 0],            y=np.array(coords1)[:, 1],            z=np.array(coords1)[:, 2],            mode="markers",            marker=dict(size=2, color="orange"),            name="Protein1",        ),        row=1,        col=1,    )    fig.add_trace(        go.Scatter3d(            x=np.array(coords2)[:, 0],            y=np.array(coords2)[:, 1],            z=np.array(coords2)[:, 2],            mode="markers",            marker=dict(size=2, color="blue"),            name="Protein2",        ),        row=1,        col=1,    )    fig.add_trace(        go.Scatter3d(            x=np.array(coords1)[:, 0],            y=np.array(coords1)[:, 1],            z=np.array(coords1)[:, 2],            mode="markers",            marker=dict(size=2, color="orange"),            name="Protein1",        ),        row=1,        col=2,    )    fig.add_trace(        go.Scatter3d(            x=coords2_rot.to_numpy()[:, 0],            y=coords2_rot.to_numpy()[:, 1],            z=coords2_rot.to_numpy()[:, 2],            mode="markers",            marker=dict(size=2, color="blue"),            name="Protein2",        ),        row=1,        col=2,    )    fig.update_layout(        scene=dict(            xaxis=dict(visible=False, showgrid=False, zeroline=False, showbackground=False),            yaxis=dict(visible=False, showgrid=False, zeroline=False, showbackground=False),            zaxis=dict(visible=False, showgrid=False, zeroline=False, showbackground=False),        ),        scene2=dict(            xaxis=dict(visible=False, showgrid=False, zeroline=False, showbackground=False),            yaxis=dict(visible=False, showgrid=False, zeroline=False, showbackground=False),            zaxis=dict(visible=False, showgrid=False, zeroline=False, showbackground=False),        ),    )    fig.show()def plot_structure_alignment_with_ret(coords1, ret1, coords2, ret2, coords2_rot, ret2_rot):    fig = make_subplots(        rows=1,        cols=2,        subplot_titles=("Before Alignment", "After Alignment"),        specs=[[{"type": "scatter3d"}, {"type": "scatter3d"}]],    )    fig.add_trace(        go.Scatter3d(            x=np.array(coords1)[:, 0],            y=np.array(coords1)[:, 1],            z=np.array(coords1)[:, 2],            mode="markers",            marker=dict(size=2, color="orange"),            name="Protein1",        ),        row=1,        col=1,    )    fig.add_trace(        go.Scatter3d(            x=np.array(coords2)[:, 0],            y=np.array(coords2)[:, 1],            z=np.array(coords2)[:, 2],            mode="markers",            marker=dict(size=2, color="blue"),            name="Protein2",        ),        row=1,        col=1,    )    fig.add_trace(        go.Scatter3d(            x=np.array(ret1)[:, 0],            y=np.array(ret1)[:, 1],            z=np.array(ret1)[:, 2],            mode="markers",            marker=dict(size=3, color="red"),            name="RET1",        ),        row=1,        col=1,    )    fig.add_trace(        go.Scatter3d(            x=np.array(ret2)[:, 0],            y=np.array(ret2)[:, 1],            z=np.array(ret2)[:, 2],            mode="markers",            marker=dict(size=3, color="green"),            name="RET2",        ),        row=1,        col=1,    )    fig.add_trace(        go.Scatter3d(            x=np.array(coords1)[:, 0],            y=np.array(coords1)[:, 1],            z=np.array(coords1)[:, 2],            mode="markers",            marker=dict(size=2, color="orange"),            name="Protein1",        ),        row=1,        col=2,    )    fig.add_trace(        go.Scatter3d(            x=coords2_rot.to_numpy()[:, 0],            y=coords2_rot.to_numpy()[:, 1],            z=coords2_rot.to_numpy()[:, 2],            mode="markers",            marker=dict(size=2, color="blue"),            name="Protein2",        ),        row=1,        col=2,    )    fig.add_trace(        go.Scatter3d(            x=np.array(ret1)[:, 0],            y=np.array(ret1)[:, 1],            z=np.array(ret1)[:, 2],            mode="markers",            marker=dict(size=3, color="red"),            name="RET1",        ),        row=1,        col=2,    )    fig.add_trace(        go.Scatter3d(            x=ret2_rot.to_numpy()[:, 0],            y=ret2_rot.to_numpy()[:, 1],            z=ret2_rot.to_numpy()[:, 2],            mode="markers",            marker=dict(size=3, color="green"),            name="RET2",        ),        row=1,        col=2,    )    fig.update_layout(        scene=dict(            xaxis_title="X",            yaxis_title="Y",            zaxis_title="Z",            aspectmode="data",        )    )    fig.update_scenes(xaxis_visible=False, yaxis_visible=False, zaxis_visible=False)    fig.show()import pandas as pdimport numpy as npimport plotly.graph_objects as gofrom scipy.spatial.transform import Rotationfrom protos.processing.structure.struct_alignment import *def align_structures(ret_a, ret_b, struct_b):    # Perform alignment based on retinals    rot, tran, _, _ = get_structure_alignment(        ret_a[["x", "y", "z"]].astype(np.float16),        ret_b[["x", "y", "z"]].astype(np.float16),    )    # Apply transformation to MO structure    struct_b_aligned = struct_b.copy()    struct_b_aligned[["x", "y", "z"]] = np.dot(        struct_b[["x", "y", "z"]].astype(np.float16).values, rot    ) + tran    # Apply transformation to MO retinal    ret_b_aligned = ret_b.copy()    ret_b_aligned[["x", "y", "z"]] = np.dot(        ret_b[["x", "y", "z"]].astype(np.float16).values, rot    ) + tran    return struct_b_aligned, ret_b_aligneddef plot_structures_with_mappings(    struct_a,    ret_a,    pdb_a,    protein_family_a,    struct_b,    ret_b,    pdb_b,    protein_family_b,    mappings,):    struct_a[["x", "y", "z"]] = struct_a[["x", "y", "z"]].astype(np.float16)    ret_a[["x", "y", "z"]] = ret_a[["x", "y", "z"]].astype(np.float16)    struct_b[["x", "y", "z"]] = struct_b[["x", "y", "z"]].astype(np.float16)    ret_b[["x", "y", "z"]] = ret_b[["x", "y", "z"]].astype(np.float16)    fig = go.Figure()    mappings = mappings.fillna("-")    mapped_grns_a = set(        mappings[(mappings[protein_family_a] != "") & (mappings[protein_family_a] != "-")][            protein_family_a        ]    )    mapped_grns_b = set(        mappings[(mappings[protein_family_b] != "") & (mappings[protein_family_b] != "-")][            protein_family_b        ]    )    def point_size(grn, mapped_grns):        return 5 if grn in mapped_grns else 2    def add_protein_fold_edges(structure, color):        for i in range(len(structure) - 1):            fig.add_trace(                go.Scatter3d(                    x=[structure["x"].iloc[i], structure["x"].iloc[i + 1]],                    y=[structure["y"].iloc[i], structure["y"].iloc[i + 1]],                    z=[structure["z"].iloc[i], structure["z"].iloc[i + 1]],                    mode="lines",                    line=dict(color=color, width=1),                    opacity=0.3,                    showlegend=False,                )            )    fig.add_trace(        go.Scatter3d(            x=struct_a["x"],            y=struct_a["y"],            z=struct_a["z"],            mode="markers",            marker=dict(                size=[point_size(grn, mapped_grns_a) for grn in struct_a["grn"]],                color="blue",                opacity=0.5,            ),            text=struct_a["grn"],            hoverinfo="text",            name=f"RBP2 ({pdb_a})",        )    )    add_protein_fold_edges(struct_a, "blue")    fig.add_trace(        go.Scatter3d(            x=ret_a["x"],            y=ret_a["y"],            z=ret_a["z"],            mode="markers",            marker=dict(size=4, color="red", opacity=0.8),            name=f"{protein_family_a} Retinal",        )    )    fig.add_trace(        go.Scatter3d(            x=struct_b["x"],            y=struct_b["y"],            z=struct_b["z"],            mode="markers",            marker=dict(                size=[point_size(grn, mapped_grns_b) for grn in struct_b["grn"]],                color="green",                opacity=0.5,            ),            text=struct_b["grn"],            hoverinfo="text",            name=f"MO ({pdb_b})",        )    )    add_protein_fold_edges(struct_b, "green")    fig.add_trace(        go.Scatter3d(            x=ret_b["x"],            y=ret_b["y"],            z=ret_b["z"],            mode="markers",            marker=dict(size=4, color="orange", opacity=0.8),            name="MO Retinal",        )    )    for _, row in mappings.iterrows():        res_a = row[protein_family_a]        res_b = row[protein_family_b]        if (res_a in mapped_grns_a) and (res_b in mapped_grns_b):            struct_a_coords = struct_a[struct_a["grn"] == res_a][["x", "y", "z"]].values[0]            struct_b_coords = struct_b[struct_b["grn"] == res_b][["x", "y", "z"]].values[0]            fig.add_trace(                go.Scatter3d(                    x=[struct_a_coords[0], struct_b_coords[0]],                    y=[struct_a_coords[1], struct_b_coords[1]],                    z=[struct_a_coords[2], struct_b_coords[2]],                    mode="lines",                    line=dict(color="purple", width=2),                    opacity=0.5,                    showlegend=False,                )            )    fig.update_layout(        scene=dict(            xaxis=dict(visible=False, showgrid=False, showline=False, zeroline=False),            yaxis=dict(visible=False, showgrid=False, showline=False, zeroline=False),            zaxis=dict(visible=False, showgrid=False, showline=False, zeroline=False),            bgcolor="rgba(0,0,0,0)",            aspectmode="cube",        ),        title=f"{protein_family_a} ({pdb_a}) and {protein_family_b} ({pdb_b}): Structure Alignment with GRN Mapping",        autosize=False,        width=800,        height=800,        paper_bgcolor="white",        plot_bgcolor="white",        margin=dict(l=0, r=0, t=40, b=0),    )    return figdef plot_aligned_structures(structures, retinals):    fig = go.Figure()    for i, (struct_df, ret_df) in enumerate(zip(structures, retinals)):        struct_x = struct_df["x"].values        struct_y = struct_df["y"].values        struct_z = struct_df["z"].values        ret_x = ret_df["x"].values        ret_y = ret_df["y"].values        ret_z = ret_df["z"].values        color = "blue"        print(color)        fig.add_trace(            go.Scatter3d(                x=struct_x,                y=struct_y,                z=struct_z,                mode="markers",                marker=dict(size=2, color=color),                name=f"Structure {i + 1}",            )        )        fig.add_trace(            go.Scatter3d(                x=ret_x,                y=ret_y,                z=ret_z,                mode="markers",                marker=dict(size=4, color="red"),                name=f"RET Structure {i + 1}",            )        )    fig.update_layout(        margin=dict(l=0, r=0, b=0, t=0),        scene=dict(            xaxis_title="X Axis",            yaxis_title="Y Axis",            zaxis_title="Z Axis",            aspectmode="data",        ),    )    fig.show()def plot_figures_in_grid(figures, names, rows, cols, size=200):    subplot_titles = [f"Structure of {n}" for n in names]    grid_fig = make_subplots(        rows=rows,        cols=cols,        subplot_titles=subplot_titles,        specs=[[{"type": "scatter3d"} for _ in range(cols)] for _ in range(rows)],    )    for i, fig in enumerate(figures):        for trace in fig.data:            grid_fig.add_trace(trace, row=(i // cols) + 1, col=(i % cols) + 1)    grid_fig.update_layout(height=size * rows, width=size * cols)    grid_fig.update_scenes(xaxis_visible=False, yaxis_visible=False, zaxis_visible=False)    grid_fig.show()def visualize_rmsd_heatmap(rmsd_matrix, structure_ids):    """    Visualize the RMSD matrix as a heatmap.    :param rmsd_matrix: Numpy array of RMSD values.    :param structure_ids: List of structure IDs corresponding to the rows and columns of the RMSD matrix.    """    plt.figure(figsize=(10, 8))    ax = sns.heatmap(        rmsd_matrix,        xticklabels=structure_ids,        yticklabels=structure_ids,        annot=True,        cmap="viridis",        linewidths=0.5,    )    plt.title("RMSD Heatmap: Structural Similarities")    plt.xlabel("Structure ID")    plt.ylabel("Structure ID")    plt.show()def create_and_visualize_similarity_tree(rmsd_matrix, structure_ids):    """    Create and visualize a similarity-based tree (dendrogram) from RMSD values.    :param rmsd_matrix: Numpy array of RMSD values.    :param structure_ids: List of structure IDs.    """    Z = linkage(rmsd_matrix, method="average", metric="euclidean")    plt.figure(figsize=(10, 8))    dendrogram(Z, labels=structure_ids, orientation="right", leaf_font_size=10)    plt.title("Similarity-based Tree of Structures")    plt.xlabel("Distance")    plt.ylabel("Structure ID")    plt.show()